#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <signal.h>

#define SHM_SIZE 4096   // Size of the shared memory region
#define MAX_STRINGS 10  // Maximum number of strings in the shared memory

// Global variable to store the scheduler's process ID
pid_t scheduler_pid;

// Structure to represent the structured shared memory data
struct SharedData {
    char strings[MAX_STRINGS][256];
    int index;
};

// Function to handle SIGALRM for the timer


void mera_khud_ka_signal_handler(int sig_number){
    if(sig_number==SIGALRM){
        printf("chalo scheduler m\n");
        kill(scheduler_pid,SIGCONT);
        pause();
    }
    else if(sig_number==SIGUSR1){
        printf("aa gya vapis shell m\n");
        kill(scheduler_pid,SIGSTOP);
        alarm(20);
    }
}

int main() {
    signal(SIGALRM,mera_khud_ka_signal_handler);
    signal(SIGUSR1,mera_khud_ka_signal_handler);
    int shm_fd;   // File descriptor for the shared memory object
    struct SharedData *shm_ptr; // Pointer to the shared memory region

    // Create or open a shared memory object
    shm_fd = shm_open("/my_shared_memory", O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    if (shm_fd == -1) {
        perror("shm_open");
        exit(1);
    }

    // Set the size of the shared memory region
    if (ftruncate(shm_fd, sizeof(struct SharedData)) == -1) {
        perror("ftruncate");
        exit(1);
    }

    // Map the shared memory into the process's address space
    shm_ptr = mmap(0, sizeof(struct SharedData), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shm_ptr == MAP_FAILED) {
        perror("mmap");
        exit(1);
    }

    // Create the scheduler process
    pid_t scheduler = fork();
    if (scheduler == -1) {
        perror("fork");
        exit(1);
    }

    if (scheduler == 0) {
        // This is the scheduler process
        execlp("./aditya_scheduler","./aditya_scheduler",NULL);
        printf("df\n");

    } 
    else if(scheduler<0){
        printf("dfg\n");
    }
    else {
        // This is the parent process (the shell and timer)

        // Set the scheduler_pid to the child process ID
        usleep(10000);
        scheduler_pid = scheduler;
        kill(scheduler_pid,SIGSTOP);
        shm_ptr->index=-1;
        while (1) {
            // Shell code
            char input[256];

            // Prompt the user for input
            alarm(20);
            printf("Enter a string (or 'exit' to quit): ");
            fgets(input, sizeof(input), stdin);

            // Remove the newline character from the input
            input[strcspn(input, "\n")] = 0;

            // Check if the user wants to exit
            if (strcmp(input, "exit") == 0) {
                break;
            }

            // Update the shared memory with the new string
            int new_index = shm_ptr->index + 1;
            if (new_index < MAX_STRINGS) {
                strcpy(shm_ptr->strings[new_index], input);
                printf("%s....\n",shm_ptr->strings[new_index]);
                shm_ptr->index++;
            } else {
                printf("Maximum number of strings reached.\n");
            }
            // Set an alarm for 10 seconds before switching to the scheduler
            // Pause the shell process until the alarm signal
            // Reset the alarm
        }

        // Remove the shared memory segment when done
        if (munmap(shm_ptr, SHM_SIZE) == -1) {
            perror("munmap");
            exit(1);
        }
        close(shm_fd);

        // Unlink the shared memory object
        if (shm_unlink("/my_shared_memory") == -1) {
            perror("shm_unlink");
            exit(1);
        }
        // Terminate the scheduler process
        kill(scheduler, SIGKILL);
    }
    return 0;
}